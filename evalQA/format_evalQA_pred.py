'''
 @Date  : 04/02/2020
 @Author: Zhihan Zhang
 @mail  : zhangzhihan@pku.edu.cn
 @homepage: ytyz1307zzh.github.io
 This script transforms a prediction.tsv file to the input format of evalQA.py
'''

import argparse
from collections import namedtuple
from typing import List, Dict
import pylev
PredictionRecord = namedtuple('PredictionRecord', 'para_id sid entity loc_before loc_after')


def normalize_location(location: str) -> str:
    if location == '-':
        return 'null'
    elif location == '?':
        return 'unk'
    else:
        return location


def compare_to_gold_labels(entity: str, gold_entities: List[str], para_id: int) -> str:

    if entity in gold_entities:
        return entity

    for gold_ent in gold_entities:
        if (pylev.levenshtein(entity, gold_ent) < 3):
            return gold_ent

    print(para_id)
    print(f"Cannot find {entity}")
    return entity


def readGold(gold_path: str):
    # read the gold label

    result = {}
    for line in open(gold_path, 'r', encoding='utf-8'):
        fields = line.rstrip().split('\t')
        para_id, sent_id, participant, before_after, labels = int(fields[0]), int(fields[1]), fields[2], fields[3], fields[4:]

        if sent_id == 1 and before_after == "before":
            state_id = 0
        elif before_after == "before":
            continue  # skip this line
        else:
            state_id = sent_id

        if para_id not in result:
            result[para_id] = {}
        para_labels = result[para_id]

        if participant not in para_labels:
            para_labels[participant] = {state_id: labels}
        else:
            para_labels[participant][state_id] = labels
            
    return result


def readPredictions(pred_path: str):
    result = {}

    for line in open(pred_path, 'r', encoding='utf-8'):
        fields = line.rstrip().split('\t')
        assert len(fields) == 6
        # discard fields[3] (the state)
        para_id, sid, entity, loc_before, loc_after = int(fields[0]), int(fields[1]), fields[2].lower(), \
                                                      fields[4].lower(), fields[5].lower()

        if para_id not in result:
            result[para_id] = {}
        para_pred = result[para_id]

        if entity not in para_pred:
            para_pred[entity] = {}

        para_pred[entity][sid] = PredictionRecord(para_id, sid, entity, loc_before, loc_after)

    return result


def writePredictions(predictions: Dict, out_path: str, gold_labels: Dict):
    """
    Split those instances where multiple entities are combined using semicolons
    """
    out_file = open(out_path, 'w', encoding='utf-8')

    for para_id, para_pred in predictions.items():
        assert type(para_pred) == dict

        for entity_fullname, ent_pred in para_pred.items():
            assert type(ent_pred) == dict
            entity_list = [x.strip() for x in entity_fullname.split(';')]

            for entity in entity_list:
                entity = compare_to_gold_labels(entity, gold_labels[para_id].keys(), para_id=para_id)

                for sent_id, sent_fields in ent_pred.items():
                    pid, sid, _, loc_before, loc_after = sent_fields  # use the after-split entity name instead of the original one
                    loc_before = normalize_location(loc_before)
                    loc_after = normalize_location(loc_after)
                    out_line = '\t'.join([str(pid), str(sid), entity, loc_before, loc_after])
                    out_file.write(out_line + '\n')

    out_file.close()


def main():

    parser = argparse.ArgumentParser()
    parser.add_argument('-prediction', type=str, required=True, help='the prediction.tsv file generated by the model')
    parser.add_argument('-output', type=str, default='prediction_evalqa.tsv')
    parser.add_argument('-gold_labels', type=str, default='gold_labels.test.tsv', help='the gold labels of evalQA task')
    opt = parser.parse_args()

    gold_labels = readGold(opt.gold_labels)
    predictions = readPredictions(opt.prediction)
    writePredictions(predictions, opt.output, gold_labels)



if __name__ == "__main__":
    main()


